use clap::{Parser, Subcommand};
use ruster::config;
use std::path::PathBuf;
use tracing::info;

#[derive(Parser)]
#[command(name = "ruster")]
#[command(about = "A software router implemented in Rust")]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// Configuration management
    Config {
        #[command(subcommand)]
        action: ConfigAction,
    },
}

#[derive(Subcommand)]
enum ConfigAction {
    /// Generate config.lock from config.toml
    Generate {
        /// Path to config.toml
        #[arg(short, long, default_value = "config.toml")]
        config: PathBuf,

        /// Output path for config.lock
        #[arg(short, long, default_value = "config.lock")]
        output: PathBuf,
    },
    /// Validate config.toml without generating lock file
    Validate {
        /// Path to config.toml
        #[arg(short, long, default_value = "config.toml")]
        config: PathBuf,
    },
}

fn main() {
    tracing_subscriber::fmt::init();

    let cli = Cli::parse();

    match cli.command {
        Some(Commands::Config { action }) => match action {
            ConfigAction::Generate {
                config: config_path,
                output,
            } => {
                if let Err(e) = cmd_config_generate(&config_path, &output) {
                    eprintln!("[ERROR] {}", e);
                    std::process::exit(1);
                }
            }
            ConfigAction::Validate {
                config: config_path,
            } => {
                if let Err(e) = cmd_config_validate(&config_path) {
                    eprintln!("[ERROR] {}", e);
                    std::process::exit(1);
                }
            }
        },
        None => {
            info!("ruster starting...");
            // TODO: Start router daemon
        }
    }
}

fn cmd_config_generate(config_path: &PathBuf, output_path: &PathBuf) -> Result<(), String> {
    println!("[INFO] Loading {}...", config_path.display());

    let content = std::fs::read_to_string(config_path)
        .map_err(|e| format!("Failed to read config file: {}", e))?;

    let cfg = config::load(config_path).map_err(|e| format!("Failed to parse config: {}", e))?;

    let validation = config::validate(&cfg);
    validation.print_diagnostics();

    if validation.has_errors() {
        return Err("Validation failed with errors".to_string());
    }

    let lock = config::generate_lock(&cfg, &content);

    let lock_toml =
        toml::to_string_pretty(&lock).map_err(|e| format!("Failed to serialize lock: {}", e))?;

    // Add header comment
    let output = format!(
        "# Generated by ruster - DO NOT EDIT\n# Source: {} (sha256: {})\n\n{}",
        config_path.display(),
        &lock.source_hash[..16],
        lock_toml
    );

    std::fs::write(output_path, output).map_err(|e| format!("Failed to write lock file: {}", e))?;

    println!("[INFO] Generated {}", output_path.display());
    Ok(())
}

fn cmd_config_validate(config_path: &PathBuf) -> Result<(), String> {
    println!("[INFO] Validating {}...", config_path.display());

    let cfg = config::load(config_path).map_err(|e| format!("Failed to parse config: {}", e))?;

    let validation = config::validate(&cfg);
    validation.print_diagnostics();

    if validation.has_errors() {
        Err("Validation failed".to_string())
    } else {
        println!("[INFO] Configuration is valid");
        Ok(())
    }
}
