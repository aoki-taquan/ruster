//! Integration tests for config CLI commands

use std::fs;
use std::process::Command;

fn cargo_bin() -> Command {
    Command::new(env!("CARGO_BIN_EXE_ruster"))
}

mod validate {
    use super::*;

    #[test]
    fn test_valid_config() {
        let output = cargo_bin()
            .args(["config", "validate", "-c", "tests/clab/config.toml"])
            .output()
            .expect("Failed to execute command");

        assert!(output.status.success());
        let stdout = String::from_utf8_lossy(&output.stdout);
        assert!(stdout.contains("Configuration is valid"));
    }

    #[test]
    fn test_missing_file() {
        let output = cargo_bin()
            .args(["config", "validate", "-c", "nonexistent.toml"])
            .output()
            .expect("Failed to execute command");

        assert!(!output.status.success());
        let stderr = String::from_utf8_lossy(&output.stderr);
        assert!(stderr.contains("Failed to read") || stderr.contains("No such file"));
    }

    #[test]
    fn test_invalid_config_missing_address() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let config_path = temp_dir.path().join("invalid.toml");

        fs::write(
            &config_path,
            r#"
[interfaces.eth0]
role = "lan"
addressing = "static"
# Missing address - should error
"#,
        )
        .expect("Failed to write config");

        let output = cargo_bin()
            .args(["config", "validate", "-c"])
            .arg(&config_path)
            .output()
            .expect("Failed to execute command");

        assert!(!output.status.success());
        let stderr = String::from_utf8_lossy(&output.stderr);
        assert!(stderr.contains("LAN interface requires static address"));
    }

    #[test]
    fn test_invalid_nat_reference() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let config_path = temp_dir.path().join("invalid_nat.toml");

        fs::write(
            &config_path,
            r#"
[interfaces.eth0]
role = "wan"
addressing = "dhcp"

[nat]
enabled = true
wan = "eth0"
lan = ["eth99"]  # eth99 doesn't exist
"#,
        )
        .expect("Failed to write config");

        let output = cargo_bin()
            .args(["config", "validate", "-c"])
            .arg(&config_path)
            .output()
            .expect("Failed to execute command");

        assert!(!output.status.success());
        let stderr = String::from_utf8_lossy(&output.stderr);
        assert!(stderr.contains("eth99"));
        assert!(stderr.contains("not defined"));
    }

    #[test]
    fn test_warnings_shown() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let config_path = temp_dir.path().join("with_warnings.toml");

        fs::write(
            &config_path,
            r#"
[interfaces.eth0]
role = "lan"
addressing = "static"
address = "192.168.1.1/24"
# mtu not specified - should warn
"#,
        )
        .expect("Failed to write config");

        let output = cargo_bin()
            .args(["config", "validate", "-c"])
            .arg(&config_path)
            .output()
            .expect("Failed to execute command");

        assert!(output.status.success());
        let stderr = String::from_utf8_lossy(&output.stderr);
        assert!(stderr.contains("[WARN]"));
        assert!(stderr.contains("mtu not specified"));
    }
}

mod generate {
    use super::*;

    #[test]
    fn test_generates_lock_file() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let lock_path = temp_dir.path().join("config.lock");

        let output = cargo_bin()
            .args(["config", "generate", "-c", "tests/clab/config.toml", "-o"])
            .arg(&lock_path)
            .output()
            .expect("Failed to execute command");

        assert!(output.status.success());
        assert!(lock_path.exists());

        let content = fs::read_to_string(&lock_path).expect("Failed to read lock file");
        assert!(content.contains("Generated by ruster"));
        assert!(content.contains("source_hash"));
        assert!(content.contains("generated_at"));
    }

    #[test]
    fn test_lock_contains_defaults() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let config_path = temp_dir.path().join("config.toml");
        let lock_path = temp_dir.path().join("config.lock");

        fs::write(
            &config_path,
            r#"
[interfaces.eth0]
role = "lan"
addressing = "static"
address = "192.168.1.1/24"
"#,
        )
        .expect("Failed to write config");

        let output = cargo_bin()
            .args(["config", "generate", "-c"])
            .arg(&config_path)
            .args(["-o"])
            .arg(&lock_path)
            .output()
            .expect("Failed to execute command");

        assert!(output.status.success());

        let content = fs::read_to_string(&lock_path).expect("Failed to read lock file");
        // Check defaults are filled in
        assert!(content.contains("mtu = 1500"));
        assert!(content.contains("mac = \"auto\""));
        assert!(content.contains("duplex = \"auto\""));
    }

    #[test]
    fn test_lock_contains_auto_routes() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let config_path = temp_dir.path().join("config.toml");
        let lock_path = temp_dir.path().join("config.lock");

        fs::write(
            &config_path,
            r#"
[interfaces.eth0]
role = "lan"
addressing = "static"
address = "10.0.1.1/24"
"#,
        )
        .expect("Failed to write config");

        let output = cargo_bin()
            .args(["config", "generate", "-c"])
            .arg(&config_path)
            .args(["-o"])
            .arg(&lock_path)
            .output()
            .expect("Failed to execute command");

        assert!(output.status.success());

        let content = fs::read_to_string(&lock_path).expect("Failed to read lock file");
        // Check auto-generated connected route
        assert!(content.contains("10.0.1.0/24"));
        assert!(content.contains("gateway = \"direct\""));
        assert!(content.contains("source = \"auto\""));
    }

    #[test]
    fn test_generate_fails_on_invalid_config() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let config_path = temp_dir.path().join("invalid.toml");
        let lock_path = temp_dir.path().join("config.lock");

        fs::write(
            &config_path,
            r#"
[interfaces.eth0]
role = "lan"
addressing = "static"
# Missing address
"#,
        )
        .expect("Failed to write config");

        let output = cargo_bin()
            .args(["config", "generate", "-c"])
            .arg(&config_path)
            .args(["-o"])
            .arg(&lock_path)
            .output()
            .expect("Failed to execute command");

        assert!(!output.status.success());
        // Lock file should not be created on error
        assert!(!lock_path.exists());
    }

    #[test]
    fn test_hash_changes_with_content() {
        let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
        let config_path = temp_dir.path().join("config.toml");
        let lock_path1 = temp_dir.path().join("config1.lock");
        let lock_path2 = temp_dir.path().join("config2.lock");

        // Generate first lock
        fs::write(
            &config_path,
            r#"
[interfaces.eth0]
role = "lan"
address = "192.168.1.1/24"
"#,
        )
        .expect("Failed to write config");

        cargo_bin()
            .args(["config", "generate", "-c"])
            .arg(&config_path)
            .args(["-o"])
            .arg(&lock_path1)
            .output()
            .expect("Failed to execute command");

        // Generate second lock with different content
        fs::write(
            &config_path,
            r#"
[interfaces.eth0]
role = "lan"
address = "192.168.2.1/24"
"#,
        )
        .expect("Failed to write config");

        cargo_bin()
            .args(["config", "generate", "-c"])
            .arg(&config_path)
            .args(["-o"])
            .arg(&lock_path2)
            .output()
            .expect("Failed to execute command");

        let content1 = fs::read_to_string(&lock_path1).expect("Failed to read lock1");
        let content2 = fs::read_to_string(&lock_path2).expect("Failed to read lock2");

        // Extract hashes
        let hash1 = content1
            .lines()
            .find(|l| l.contains("source_hash"))
            .unwrap();
        let hash2 = content2
            .lines()
            .find(|l| l.contains("source_hash"))
            .unwrap();

        assert_ne!(hash1, hash2, "Hashes should differ for different content");
    }
}
